#------------------------------------------------------------------------------
# README
# author:  Jason Raber
# company: HexEffect, LLC www.hexeffect.com  2013
#------------------------------------------------------------------------------

NOTE: Please read the WhitePaper.docx to get an overview of what the Virtual
Deobfuscator is and how it works.

This readme is focused on details pertaining to:
- What you need to install first
- Manifest
- Quick Start
- Sections
- Binary Repackager
- Peephole Optimizer 


What you need to install first
-------------------------------------------------------------------------------
1 - Python 2.7
--------------
Windows:
  Get the current Python 2.7 installer from http://www.python.org/getit/. After
  installation, update your PATH to include your Python directory (C:\Python27
  by default).

Mac and Linux:
  Should be good to go by default.

2 - LXML 
--------
Windows:
  Get the current lxml package from https://pypi.python.org/pypi/lxml/. Make
  sure to get the one that patches your python install (2.7, 32- or 64-bit).

Mac and Linux:
  pip install lxml


Manifest
-------------------------------------------------------------------------------
VirtualDeobfuscator.py
    Main Virtual Deobfuscator source file
VD_Peephole.py
    Peephole optimizer
utils.py
    Support functions
cluster.py
    Clustering code

doc/
  README.txt
      This file
  WhitePaper.docx
      White paper describing the Virtual Deobfuscator

examples/
  olly_loop_eax.txt
      A runtrace of the binary "sample_loop_exe.exe"
  main.cpp
      The sample_loop_exe src code
  sample_loop_eax.exe
      Binary to create a runtrace from
  final_assembly.txt
      This is the final assembly file for olly_loop_eax.txt as a way to verify
      your results
  vd.xml
      Database generated by Virtual Deobfuscator from olly_loop_eax.txt


Sections
-------------------------------------------------------------------------------
sections
--------
-s <section size>
Use the switch -s <section size> to output sections of assembly code.

Example:    
C:\xxx\VirtualDeobfuscator>python VirtualDeobfuscator.py -i CV_rt.txt -d 1
C:\xxx\VirtualDeobfuscator>python VirtualDeobfuscator.py -c -d 1 -s 1300

This will create a new dir called chunk_sections/.  The sections will contain
all of the interpreted instructions of the original program.

Let's take a look at an example:

k2__________________________________________________#3265 [15, 990] 15 (5807)
e32___________#101                                        [16, 224] 16 (9072)
e56________#76                                          
e57___________#101                                     
f34___________#173                                    
g18_______________#343                               
f37___________#173                                  
f38___________#179                                 
e64________#79                                    
k3________________________________________________#2919    [24, 47] 24 (10297)

As you can see, clusters k2___ and k3___ are the seams to OS and VM transitions. 
Now  we need all the instructions in the middle. (e32_, e56_,..., e64_).  So 
with the size constrant of 1,300 we capture all instructions below this range 
and add them to their own section (file).  Take the starting and ending line 
numbers of this particular section and we have:
10297 - 9072 = 1,225 ins.  Note: don't use 5807 as the starting point, as that 
is the beginning of k2 cluster.

OK...now go to dir "chunk_sections/" and open "23.txt".  You will see all the
instructions for e32_ to e64_ all together.   If you go to the bottom of the
file you will see there is exactly 1,225 ins.  Sweet action!

The file name "23.txt" reflects the file offset in final_assembly.txt.  Just
an easy way to find your sections.


So why create all these sections?
- That is where our instructions of interest are at. So before peephole, let's
assemble those new sections
  
  
  
Binary Repackager
-------------------------------------------------------------------------------
NASM (The Netwide Assembler) http://www.nasm.us/

Once it is installed it will create a dir called: nasm/ but it will also
create a shortcut console shell called: 'nasm-shell' under the start menu
Netwide Assembler 2.10.07.  

When you are ready to start assembling files, Just run the shell and cd to
the VirtualDeobfuscator source directory and you are ready to roll. (NOTE: 
do not run python VirtualDeobfuscator.py -options in this CLI, I have not 
tested that.  I just run the assembler in that shell...use Windows cmd to 
run VD.


To recreate assembly files, run the following commands:
Example (Olly 2.0):
  python VirtualDeobfuscator.py -i CV_rt.txt -d 1
  python VirtualDeobfuscator.py -c -d 1 -s 1300

VD's assembly outputs will end up in a chunk_sections/ subdirectory.

How to assemble new runtraces
-----------------------------
A new dir called chunk_sections/ is created.  Go to this directory and you
should see a lot of .asm files.

Files will be named with line numbers found in final_assembly.txt  Previously,
covered in more detail in our last milestone.  Now rather than a bunch of .txt
files I renamed the extensions to .asm for color syntax goodness found in gvim.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**** Note the files called #_nasm.asm (e.g. 14_nasm.asm), these files are what
     we are going to assemble.

Next, bring up the 'nasm-shell' and go to this directory.
Run:
> nasm -f win32 #_nasm.asm
You should get a file called #_nasm.obj

Next: Load this file in IDA Pro and see the beatific disassembly!  

> nasm -f win32 final_assembly_nasm.asm
Now disassemble final_assembly_nasm.obj 

final_assembly_nasm.asm
-----------------------
This file is the concatenation of all the sections (clusters) that are in the
seams of our larger clusters (VM transitions).  Anyways, this is easier to
assemble all the sections at once instead of them individually.  

Peephole Optimizer
-------------------------------------------------------------------------------
I figured that the peephole optimizer would be handling simple inefficiencies
found in translation from one architecture to another.  However, the Peephole
turned more into a machine code deobfuscator.


To use the Peephole you must first assemble the target .asm file.  i.e.
> nasm -f win32 #_nasm.asm
which gives us #_nasm.obj

Now disassemble this guy with IDA Pro.
NOTE: I have tested this with IDA Pro Version 6.4.130.



Run it
------
Now in the "Output window" you can run the file with

> execfile("VD_Peephole.py")

What is nice about this, is after you close IDA and reopen on another binary
it will keep that command in its history, so, up arrow for the win!
If that method does not work for you, you can always load it from the file
menu:
"File"->"Script File"

If you want to see a lot of debug info displayed to the Output window then 
change the debug flag in VD_Peephole.py near the top

debug = 0 # max is 3

Output
------
After running the plugin, it will create a file called "1_nasm.asm".  This
file is the optimized (MCD) representation of the original section.  You can 
change this output file name to anything you like...just change:

ROUND = "1_nasm.asm"

I intended for this to increment every time I run it, but, well I ran out of
time.

So, re-assemble this file, and begin the process over until there are no more
peephole optimizations found.

Good luck

